<template>
  <FormPage @submit='onSubmit' label='MSG_SETUP_AFFILIATE' submit-text='MSG_CREATE_AFFILIATE' :submitting='submitting'>
    <template #form-body>
      <h3 class='aff-name'>
        {{ username }}
      </h3>
      <p class='aff-email'>
        {{ subUsername }}
      </p>
      <div v-for='(_good, idx) in visibleGoodArchivements' :key='idx'>
        <label>{{ _good.GoodName }} {{ $t('MSG_KOL_COMMISSION_RATE') }}:</label>
        <input type='number' v-model='_good.CommissionPercent' :min='0' :max='getGoodPercent(_good.GoodID)'>
      </div>
    </template>
    <template #append-submit>
      <h3>{{ $t('MSG_INFO') }}</h3>
      <p v-html='$t("MSG_SETUP_AFFILIATE_INFO")' />
    </template>
  </FormPage>
</template>

<script setup lang='ts'>
import {
  useInspireStore,
  NotificationType
} from 'npool-cli-v2'
import {
  useLocalUserStore,
  useBaseUserStore,
  User,
  useAdminAppGoodStore,
  useFrontendArchivementStore,
  UserArchivement,
  NotifyType
} from 'npool-cli-v4'
import { defineAsyncComponent, computed, onMounted, ref } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useI18n } from 'vue-i18n'
import { getAppGoods } from 'src/api/good'
// eslint-disable-next-line @typescript-eslint/unbound-method
const { locale, t } = useI18n({ useScope: 'global' })

const FormPage = defineAsyncComponent(() => import('src/components/page/FormPage.vue'))

interface Query {
  userID: string;
}

const route = useRoute()
const router = useRouter()
const query = computed(() => route.query as unknown as Query)

const archivement = useFrontendArchivementStore()
const referral = computed(() => archivement.getArchivementByUserID(query.value?.userID))

const baseUser = useBaseUserStore()
const username = computed(() => baseUser.displayName({
  FirstName: referral.value?.FirstName,
  LastName: referral.value?.LastName
} as User, locale.value as string))
const subUsername = computed(() => archivement.subUsername(referral.value as UserArchivement))

const logined = useLocalUserStore()

const good = useAdminAppGoodStore()
const getGoodPercent = computed(() => (goodID: string) => {
  const inviterArchivement = archivement.getArchivementByUserID(logined?.User.ID)
  return archivement.getInviterGoodPercent(inviterArchivement as UserArchivement, goodID)
})

const visibleGoodArchivements = computed(() => referral.value?.Archivements?.filter((el) => good.visible(el.GoodID)))

const backTimer = ref(-1)
const submitting = ref(false)

const inspire = useInspireStore()
const onSubmit = () => {
  submitting.value = true
  referral.value?.Archivements?.forEach((g) => {
    if (g.CommissionPercent > getGoodPercent.value(g.GoodID)) {
      g.CommissionPercent = getGoodPercent.value(g.GoodID)
    }
    if (g.CommissionPercent < 0) {
      g.CommissionPercent = 0
    }
  })

  inspire.createInvitationCode({
    TargetUserID: referral.value?.UserID as string,
    InviterName: baseUser.displayName(logined.User, locale.value as string),
    InviteeName: username.value,
    Info: {
      UserID: referral.value?.UserID
    },
    Message: {
      Error: {
        Title: t('MSG_CREATE_INVITATION_CODE_FAIL'),
        Popup: true,
        Type: NotificationType.Error
      }
    }
  }, (error: boolean) => {
    submitting.value = false
    if (error) {
      return
    }
    if (visibleGoodArchivements.value?.length === 0) {
      archivement.$reset()
      void router.push({ path: '/affiliates' })
      return
    }
    visibleGoodArchivements?.value?.forEach((good) => {
      inspire.createPurchaseAmountSetting({
        TargetUserID: referral.value?.UserID as string,
        InviterName: baseUser.displayName(logined.User, locale.value as string),
        InviteeName: username.value,
        Info: {
          GoodID: good.GoodID,
          CoinTypeID: good.CoinTypeID,
          Percent: good.CommissionPercent,
          Start: Math.ceil(Date.now() / 1000),
          End: 0
        },
        Message: {
          Error: {
            Title: t('MSG_CREATE_AMOUNT_SETTING_FAIL'),
            Popup: true,
            Type: NotificationType.Error
          }
        }
      }, () => {
        if (backTimer.value >= 0) {
          window.clearTimeout(backTimer.value)
        }
        backTimer.value = window.setTimeout(() => {
          archivement.$reset()
          void router.push({ path: '/affiliates' })
        }, 1000)
      })
    })
  })
}

onMounted(() => {
  if (good.AppGoods.AppGoods.length === 0) {
    getAppGoods(0, 500)
  }
  if (archivement.Archivements.Archivements.length === 0) {
    getArchivements(0, 100)
  }
})

const getArchivements = (offset: number, limit: number) => {
  archivement.getGoodArchivements({
    Offset: offset,
    Limit: limit,
    Message: {
      Error: {
        Title: t('MSG_GET_COIN_ARCHIVEMENT_FAIL'),
        Popup: true,
        Type: NotifyType.Error
      }
    }
  }, (error: boolean, rows: Array<UserArchivement>) => {
    if (error || rows.length < limit) {
      return
    }
    getArchivements(offset + limit, limit)
  })
}
</script>

<style lang='sass' scoped>
</style>
